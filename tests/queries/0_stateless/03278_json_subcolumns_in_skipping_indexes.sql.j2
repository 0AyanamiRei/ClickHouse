-- Tags: long

set optimize_read_in_order=1;
set allow_experimental_json_type=1;
set allow_experimental_variant_type=1;
set use_variant_as_common_type=1;

drop table if exists test;

{% for create_command in ['create table test (id UInt64, json JSON(a UInt32), data String, index idx1 json.a type minmax, index idx2 json.b::String type minmax, index idx3 json.a || json.b::String type minmax) engine=MergeTree order by tuple() settings min_rows_for_wide_part=100000000, min_bytes_for_wide_part=1000000000, vertical_merge_algorithm_min_columns_to_activate=10;',
                          'create table test (id UInt64, json JSON(a UInt32), data String, index idx1 json.a type minmax, index idx2 json.b::String type minmax, index idx3 json.a || json.b::String type minmax) engine=MergeTree order by tuple() settings min_rows_for_wide_part=1, min_bytes_for_wide_part=1, vertical_merge_algorithm_min_columns_to_activate=10;',
                          'create table test (id UInt64, json JSON(a UInt32), data String, index idx1 json.a type minmax, index idx2 json.b::String type minmax, index idx3 json.a || json.b::String type minmax) engine=MergeTree order by tuple() settings min_rows_for_wide_part=100000000, min_bytes_for_wide_part=1000000000, vertical_merge_algorithm_min_columns_to_activate=1;',
                          'create table test (id UInt64, json JSON(a UInt32), data String, index idx1 json.a type minmax, index idx2 json.b::String type minmax, index idx3 json.a || json.b::String type minmax) engine=MergeTree order by tuple() settings min_rows_for_wide_part=1, min_bytes_for_wide_part=1, vertical_merge_algorithm_min_columns_to_activate=1;'] -%}

select '{{ create_command }}';

{{ create_command }}

system stop merges test;
insert into test select number, toJSONString(map('a', number, 'b', 'str_' || number, 'c', range(number % 10))), 'Hello, World!' from numbers(10);
insert into test select number, toJSONString(map('a', number, 'b', 'str_' || number, 'c', range(number % 10))), 'Hello, World!' from numbers(20, 10);

select * from test where json.a < 2 order by all;
select * from test where json.b::String < 'str_2' order by all;
select * from test where json.a < 2 and json.b::String < 'str_2' order by all;
select * from test where json.a || json.b::String < '2str_2' order by all;

system start merges test;
optimize table test final;
select count() from system.parts where active and table = 'test' and database = currentDatabase();

select * from test where json.a < 2 order by all;
select * from test where json.b::String < 'str_2' order by all;
select * from test where json.a < 2 and json.b::String < 'str_2' order by all;
select * from test where json.a || json.b::String < '2str_2' order by all;

truncate table test;

insert into test select number, toJSONString(map('a', number, 'b', 'str_' || number, 'c', range(number % 10))), 'Hello, World!' from numbers(100000);
insert into test select number, toJSONString(map('a', number, 'b', 'str_' || number, 'c', range(number % 10))), 'Hello, World!' from numbers(200000, 100000);

select * from test where json.a < 2 format Null;
select trimLeft(explain) from (explain indexes=1 select * from test where json.a < 2) where explain ilike '%indexes%' or explain ilike '%skip%';
select * from test where json.b::String < 'str_2' format Null;
select trimLeft(explain) from (explain indexes=1 select * from test where json.b::String < 'str_2') where explain ilike '%indexes%' or explain ilike '%skip%';
select * from test where json.a < 2 and json.b::String < 'str_2' format Null;
select trimLeft(explain) from (explain indexes=1 select * from test where json.a < 2 and json.b::String < 'str_2') where explain ilike '%indexes%' or explain ilike '%skip%';
select * from test where json.a || json.b::String < '2str_2' format Null;
select trimLeft(explain) from (explain indexes=1 select * from test where json.a || json.b::String < '2str_2') where explain ilike '%indexes%' or explain ilike '%skip%';

system start merges test;
optimize table test final;
select count() from system.parts where active and table = 'test' and database = currentDatabase();

select * from test where json.a < 2 format Null;
select trimLeft(explain) from (explain indexes=1 select * from test where json.a < 2) where explain ilike '%indexes%' or explain ilike '%skip%';
select * from test where json.b::String < 'str_2' format Null;
select trimLeft(explain) from (explain indexes=1 select * from test where json.b::String < 'str_2') where explain ilike '%indexes%' or explain ilike '%skip%';
select * from test where json.a < 2 and json.b::String < 'str_2' format Null;
select trimLeft(explain) from (explain indexes=1 select * from test where json.a < 2 and json.b::String < 'str_2') where explain ilike '%indexes%' or explain ilike '%skip%';
select * from test where json.a || json.b::String < '2str_2' format Null;
select trimLeft(explain) from (explain indexes=1 select * from test where json.a || json.b::String < '2str_2') where explain ilike '%indexes%' or explain ilike '%skip%';

drop table test;

{% endfor -%}

